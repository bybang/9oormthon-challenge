# Goormthon Challenge Day 16

### êµ¬ë¦„í†¤ ì½”ë”©í…ŒìŠ¤íŠ¸ ì±Œë¦°ì§€ 4ì£¼ì°¨ ì²« ë²ˆì§¸ ë‚ ,

> êµ¬ë¦„í†¤ 4ì£¼ì°¨ê°€ ì‹œì‘ëë‹¤. ì´ë²ˆ ì£¼ì—ëŠ” ê·¸ë˜í”„ íƒìƒ‰ë¬¸ì œ ìœ„ì£¼ë¡œ ë‚˜ì˜¤ëŠ” ì£¼ë¼ê³  í•œë‹¤.

# ğŸ§© ë¬¸ì œ

# ğŸ¯ ì „ëµ
### ì¡°ê±´ ë¶„ì„í•˜ê¸°
ì£¼ì–´ì§„ ì¡°ê±´ì„ ì‚´í´ë³´ë©´ í¬ê²Œ ì„¸ ê°€ì§€ë¡œ ë‹¤ìŒê³¼ ê°™ë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.
1. ì„ì˜ì˜ ë‘ ì„¬ a, bì— ì–‘ë°©í–¥ ë‹¤ë¦¬(ê°„ì„ ì´)ê°€ ìˆë‹¤ë©´ 'ì—°í•©'ìœ¼ë¡œ ì·¨ê¸‰í•œë‹¤.
2. a, bê°€ ì—°í•©ì´ê³  b, c ê°€ ì—°í•©ì¼ ë•ŒëŠ” a, b, cë¥¼ ê°™ì€ ì—°í•©ì— ì†í•´ìˆë‹¤ê³  ë³¸ë‹¤.
(ì¦‰, ì–´ë–¤ ì„¬ì—ì„œ ì¶œë°œí•˜ë”ë¼ë„ ì—°í•©ì´ë¼ë©´ ì—°í•© ë‚´ì˜ ëª¨ë“  ì„¬ì„ ê°ˆ ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤.)
3. ë‹¤ë¥¸ ì„¬ê³¼ ì—°í•©ì„ ê²°ì„± í•˜ì§€ ì•Šì•„ë„ ëª¨ë“  ì„¬ì€ ê°ê° í•˜ë‚˜ì˜ ì—°í•©ì— ì†í•´ìˆë‹¤.

ëª¨ë“  ì„¬ì„ ì²´í¬í•´ ì—°í•©ì— ì†í•˜ëŠ”ì§€ í™•ì¸í•´ì•¼ í•˜ë¯€ë¡œ, BFSë¥¼ í™œìš©í•´ ë¬¸ì œë¥¼ í’€ì.

### ë°ì´í„° ì…ë ¥ ë°›ê¸°
ê·¸ë˜í”„ë¥¼ ì…ë ¥ë°›ì„ ë•Œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë°©ì‹ì„ í™œìš©í•˜ì—¬ ê·¸ë˜í”„ë¥¼ ê·¸ë¦¬ê³ , ê°„ì„ (edge)ì™€ ë¹ˆ ì—°í•© ë°°ì—´ë„ ì„ ì–¸í•´ì£¼ì.
ì‹œì‘ ë…¸ë“œ(s)ì™€ ë ë…¸ë“œ(e)ë¥¼ ì…ë ¥ë°›ì•˜ë‹¤ë©´, ê·¸ë˜í”„ë¥¼ ì´ìš©í•´ s-e í˜•ì‹ìœ¼ë¡œ `append(e)` í•´ì£¼ì.

ë§ˆì§€ë§‰ì€ ì—°í•©ì˜ ìˆ˜ë¥¼ ë‚˜íƒ€ë‚´ëŠ” `union_count`ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™” í•´ ì„ ì–¸í•´ì£¼ë©´ ë°ì´í„° ì´ˆê¸° ì„¸íŒ…ì€ ì™„ë£Œëœë‹¤.

```python
N, M = map(int, input().split())

graph = [[] for _ in range(N + 1)]
union = [0] * (N + 1)

for _ in range(M):
    s, e = map(int, input().split())
    graph[s].append(e)

union_count = 0
```

### ë°˜ë³µë¬¸ í™œìš©í•´ BFS ì¡°ê±´ ë§Œë“¤ê¸°
0ë²ˆ ì„¬ì€ ì—†ìœ¼ë¯€ë¡œ 1ë²ˆ ì„¬ë¶€í„° Në²ˆ ì„¬ê¹Œì§€ ë°˜ë³µë¬¸ì„ ì„ ì–¸í•´ì£¼ì ë²”ìœ„: `(1, N+1)`

ì„¬ë“¤ì„ ëŒë©´ì„œ ì´ë²ˆ ì„¬ì´ ì—°í•©ì— ì´ë¯¸ ì†í•´ ìˆë‹¤ë©´ ë¬´ì‹œí•´ì£¼ê³ , ì†í•´ìˆì§€ ì•Šë‹¤ë©´ ì„¬ ë²ˆí˜¸ë¥¼ íì— ë„£ì–´ì„œ
BFSë¥¼ í™œìš©í•´ ì „ì²´ íƒìƒ‰ì„ ì§„í–‰í•´ì¤€ë‹¤. í˜„ ê³¼ì •ì„ ì§„í–‰í•œë‹¤ë©´ ì—°ê²° ë˜ì–´ìˆëŠ” ì„¬ì´ ìˆë“  ì—†ë“  ìì²´ì ìœ¼ë¡œ ì—°í•©ì„
ê°€ì§€ê¸°ì— `union_count + 1`ì„ í•´ì£¼ê³  í˜„ì¬ ì„¬ì„ ì—°í•©[i]ì— 0 ëŒ€ì‹  1ì„ ì±„ì›Œì£¼ë©° ì—°í•© ì²´í¬ ì™„ë£Œ í‘œì‹œë¥¼ í•´ì¤€ë‹¤.

(ë§Œì•½ ì—°í•©[i]ê°€ ì¡´ì¬í•œë‹¤ë©´(1ì´ë¼ë©´), ì–‘ë°©í–¥ ê°„ì„ ì´ë¼ëŠ” ëœ»ì´ë¯€ë¡œ ë” ì´ìƒì˜ ë°ì´í„° ì²˜ë¦¬ë¥¼ í•´ì¤„ í•„ìš”ê°€ ì—†ë‹¤.)

```python
...
for i in range(1, N + 1):
    if union[i]:
        continue
        
    q = deque([i])
    union_count += 1
    union[i] = 1
    
    while q:
        current = q.popleft()  
```

ê·¸ë¦¬ê³  í˜„ì¬ ë…¸ë“œë¥¼ íƒìƒ‰ì— ì‚¬ìš©í•´ì£¼ê¸° ìœ„í•´ `q.popleft()`ë¡œ ì²˜ë¦¬í•´ì¤€ë‹¤.

### ê·¸ë˜í”„ íƒìƒ‰í•˜ê¸°
í˜„ì¬ ë…¸ë“œë¥¼ êµ¬í–ˆë‹¤ë©´ íƒìƒ‰ì— í™œìš©í•  ë•Œë‹¤.
1. ë¨¼ì € ê·¸ë˜í”„ë¥¼ í˜„ì¬ ë…¸ë“œê°’ì„ í™œìš©í•´ íƒìƒ‰í•´ì¤€ë‹¤.
ê·¸ë˜í”„ëŠ” ë¦¬ìŠ¤íŠ¸ë“¤ë¡œ ì´ë£¨ì–´ì§„ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë°©ì‹ì˜ ê·¸ë˜í”„ ì´ë¯€ë¡œ, `graph[current]`ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ì¢…ì† ë³€ìˆ˜ë¡œ ê°€ì§€ê³  ìˆë‹¤.
`item`ì€ ê·¸ë˜í”„[í˜„ì¬ë…¸ë“œ] ë¦¬ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ ë³€ìˆ˜ì´ë¯€ë¡œ í˜„ì¬ ë…¸ë“œ(ì„¬)ì—ì„œ ì²´í¬ ê°€ëŠ¥í•œ ì„¬ë“¤ ì¤‘ì—ì„œ në²ˆì§¸ ë³€ìˆ˜ëŠ”... ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

```python
...
    while q:
        current = q.popleft()
        
        for item in graph[current]:
```
2. ì¡°ê±´ë¬¸ì„ í™œìš©í•˜ì—¬ ì—°í•©ì¸ì§€ ì—¬ë¶€ë¥¼ ì²´í¬í•´ ì¤€ë‹¤.
ê°€ì¥ ë¨¼ì € ì—°í•©[në²ˆì§¸ ë³€ìˆ˜]ë¥¼ í™œìš©í•˜ì—¬ ì—°í•© ì²´í¬ë¥¼ ë§ˆì³¤ëŠ”ì§€(0ì¸ì§€ 1ì¸ì§€)ë¥¼ íŒŒì•…í•´ì£¼ê³  0ì´ë¼ë©´, ë‹¤ìŒìœ¼ë¡œ í˜„ì¬ ë…¸ë“œ(ì„¬ ë²ˆí˜¸)ê°€
ê·¸ë˜í”„[në²ˆì§¸ ë³€ìˆ˜]ì˜ ì•ˆì— ì¡´ì¬í•˜ëŠ”ì§€ ì²´í¬í•´ ì¤€ë‹¤. ê·¸ë˜í”„ ì•ˆì˜ ì„¬ê³¼ í˜„ì¬ ì„¬ì˜ ë²ˆí˜¸ê°€ ê°™ë‹¤ë©´ ê°„ì„ ì´ ì¡´ì¬í•˜ëŠ” ê²ƒì´ë‹¤.

```
(ì˜ˆ) ì²« ë²ˆì§¸ ì˜ˆì‹œ ì¤‘ - 
í˜„ì¬ë…¸ë“œ == 1, ê·¸ë˜í”„[1] == [2,4] / ê·¸ë˜í”„[2] == [3,4] / ê·¸ë˜í”„[4] == [1], ì²« ë²ˆì§¸ ì•„ì´í…œ == 2

ì•„ì´í…œ == 2 ì¼ë•Œ, ì—°í•©[2] == 0(ë¯¸ì²´í¬), 1 in ê·¸ë˜í”„[2] ? > False
ì•„ì´í…œ == 4 ì¼ë•Œ, ì—°í•©[4] == 0(ë¯¸ì²´í¬), 1 in ê·¸ë˜í”„[4] ? > True )
```

ë‘ ê°€ì§€ ì¡°ê±´ì„ ëª¨ë‘ ë§Œì¡±í•  ë•Œ(ì—°í•© ì²´í¬ê°€ ì•„ì§ì¸ ë³€ìˆ˜, ê°„ì„ ì˜ ì—¬ë¶€) ë‹¤ìŒ íì— ëŒ€ê¸°ì‹œì¼œì£¼ê³ , ì—°í•©[në²ˆì§¸ë³€ìˆ˜]ë¥¼ ì²´í¬ ì™„ë£Œ ì²˜ë¦¬(1) í•´ì¤€ë‹¤.

```python
...
    while q:
        current = q.popleft()
        
        for item in graph[current]:
            if not union[item] and current in graph[item]:
                q.append(item)
                union[item] = 1
```

ë§ˆì§€ë§‰ìœ¼ë¡œ ì—°í•©ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•´ì£¼ë©´ ëœë‹¤. ì—°í•©ì˜ ê°œìˆ˜ëŠ” `if union[i]` ë¶€ë¶„ì´ ê²°ì •í•˜ëŠ” ê²ƒì´ë‹¤.(ì–‘ë°©í–¥ ê°„ì„ ì´ë¼ë©´ ì¼ë ¨ì˜ ê³¼ì •ì„ ìƒëµí•˜ë¯€ë¡œ ì¹´ìš´íŠ¸ ë³€í™” X)

# ğŸ“Œ ëŠë‚€ì 
BFSë¡œ í’€ë©´ ë” ê°„ë‹¨í•˜ê²Œ í’€ ìˆ˜ ìˆì—ˆëŠ”ë° BFSì˜ í™œìš©ë²•ì´ ìƒê°ë‚˜ì§€ ì•Šì•„ì„œ ì „ì— ê³µë¶€í–ˆë˜ ìœ ë‹ˆì˜¨ íŒŒì¸ë“œì˜ ê°œë…ì„ í™œìš©í•´ì„œ í’€ì—ˆë‹¤.
í™•ì‹¤íˆ ì–´ë ¤ìš´ ê°œë…ìœ¼ë¡œ ì ‘ê·¼í•˜ì§€ ì•Šì•„ë„ DFS/BFSë©´ í’€ë¦¬ëŠ” ë¬¸ì œë“¤ì´ ë§ì€ ê²ƒ ê°™ë‹¤ëŠ” ëŠë‚Œì´ ë“ ë‹¤. ë¦¬íŠ¸ì½”ë“œë¥¼ í™œìš©í•´ì„œ íƒìƒ‰ ìª½ ë¬¸ì œë¥¼
ë” ë§ì´ ì ‘í•´ë´ì•¼ ì‰½ê²Œ BFSë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ ë¼ëŠ” ìƒê°ì´ ë“ ë‹¤.

# ğŸ’» í’€ì´

```python
from collection import deque

N, M = map(int, input().split())
graph =[[] for _ in range(N + 1)]
union = [0] * (N + 1)

union_count = 0

for _ in range(M):
    s, e = map(int, input().split())
    graph[s].append(e)
    
for i in range(N + 1):
    if union[i]:
        continue
    
    q = deque([i])
    union_count += 1
    union[i]
    
    while q:
        current = q.popleft()
        
        for item in graph[current]:
            if not union[item] and current in graph[item]:
                q.append(item)
                union[item] = 1
                
print(union_count)
```

ë‚´ê°€ í’€ì—ˆë˜ ë°©ë²•

```python
# My Solution
def find_parent(parent, x):
	if parent[x] != x:
		parent[x] = find_parent(parent, parent[x])
	return parent[x]

def union_parent(parent, a, b):
	a = find_parent(parent, a)
	b = find_parent(parent, b)

	if a < b:
		parent[b] = a
	else:
		parent[a] = b

N, M = map(int, input().split())
graph = [[] for _ in range(N + 1)]
parent = [0] * (N + 1)

for i in range(1, N + 1):
	parent[i] = i

union_count = set()

for _ in range(M):
	s, e = map(int, input().split())
	graph[s].append(e)

for start in range(1, N+1):
	for item in graph[start]:
		if start in graph[item]:
			union_parent(parent, start, item)

for k in range(1, N + 1):
	union_count.add(find_parent(parent, k))

print(len(union_count))
```


# ğŸ”– ë³µìŠµ
```python
BFSë¡œ ë¬¸ì œ ì ‘ê·¼í•´ë³´ê¸°
ì „ì— ì¼ì—ˆë˜ ë°©ë¬¸ ë°°ì—´, ì´ë²ˆì— ì“´ ì—°í•© ì²´í¬ ë°°ì—´ë„ ê°™ì€ ë§¥ë½ì˜ ë¬¸ì œì´ë‹¤!

union = [0] * (N + 1)

for i in range(N + 1):
    if union[i]:
        continue
        
BFSë¡œ ì ‘ê·¼í–ˆë‹¤ë©´ ì–´ë–¤ ë°ì´í„° êµ¬ì¡°ë¥¼ í†µí•´ ì›í•˜ëŠ” ë‹µì„ ë„ì¶œí•  ê²ƒì¸ê°€ ë¥¼ ìƒê°í•´ë³´ê¸°
ì‹¤ì œë¡œ ì´ë²ˆ BFSë¥¼ ì“°ì§€ ëª»í–ˆë˜ ì´ìœ  ì¤‘ í•˜ë‚˜ëŠ” union_countë¥¼ ì›í•˜ëŠ” ë°©ì‹ëŒ€ë¡œ ë„ì¶œí•´ ë‚¼ ìˆ˜ ì—†ì—ˆê¸° ë•Œë¬¸ì´ë‹¤.

for i in range(N + 1):
    if union[i]:
        continue
        
    union_count += 1
    union[i] = 1
    
ë³µì¡í•œ ì¡°ê±´ë¬¸ì€ ë§ë¡œ í’€ì–´ì„œ ì“°ë©° ì´í•´í•˜ê¸°
ì‹¤ì œë¡œ ìœ ìš©í•œ ë””ë²„ê¹… ë°©ë²•ì¤‘ í•˜ë‚˜ì¸ rubber duck debuggingì„ ë´ë„ ì•Œ ìˆ˜ ìˆë“¯ì´ ë§ë¡œ ì„¤ëª…í•˜ë©´ ëª»í’€ë˜ ë¬¸ì œë„ í•´ê²°ë˜ê³¤ í•œë‹¤.
ì˜ˆ)
ì•„ì´í…œ == 2 ì¼ë•Œ, ì—°í•©[2] == 0(ë¯¸ì²´í¬), 1 in ê·¸ë˜í”„[2] ? > False
ì•„ì´í…œ == 4 ì¼ë•Œ, ì—°í•©[4] == 0(ë¯¸ì²´í¬), 1 in ê·¸ë˜í”„[4] ? > True
    ...
    while q:
        current = q.popleft()
        
        for item in graph[current]:
            if not union[item] and current in graph[item]:
                q.append(item)
                union[item] = 1
```